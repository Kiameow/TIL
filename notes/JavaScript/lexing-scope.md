## 作用域链

```js
const fullName = "Oluwatobi Sofela";

// 定义多层嵌套函数：
function profile() {
  function sayName() {
    function writeName() {
      return fullName;
    }
    return writeName();
  }
  return sayName();
}

console.log(profile()) // 'Oluwatobi Sofela'
```

当`profile`函数被调用时，对于`fullName`变量的查找路径，依循作用域链writeName() -> sayName() -> profile() -> 全局作用域

一旦在其中一环找到了该变量，便会停止向下，并返回在该作用域下变量的值。

如果在最后的全局作用域都找不到，那么就会raise Error: `Uncaught ReferenceError: fullName is not defined`

## 作用域内外规则
外部的作用域如上所述，是可以一步步访问到的， 但是对于内部的作用域无法访问， 就像profile无法直接访问到在`sayName()`或`writeName()`中定义的变量

## 词法作用域
词法作用域，顾名思义，就是变量的声明位置决定了它的作用域，就是存在作用域链的。函数在被调用时，适用于上面所说的规则。

## 动态作用域
而动态作用域， 则是指变量的声明位置不决定它的作用域。当函数执行，去找变量定义的时候，不会循着所谓的作用域链去一步步寻找，而是直接在函数被执行的那个作用域里找变量定义。

看一个例子：
```js
var a = 2;

function foo() {
  console.log(a); // 如果是动态作用域，会输出3
}

function bar() {
  var a = 3; // 动态作用域 输出的是这个变量
  foo();
}

bar();
```
也就是说，词法作用域使得代码呈现出一种确定性，函数的声明位置把作用域链这个变量寻找规则定死了，故而词法作用域也称为静态作用域，使用者需要关注函数在何处声明；而动态作用域使得代码的真实含义在运行时确定，因而使用者需关注函数在何处被调用。

bash使用的就是动态作用域。

## 块级作用域和函数作用域
块级作用域和函数作用域的概念属于词法作用域的派生。

ES6之前，js不存在块级作用域，即不存在大括号可以作为一个作用域隔离内部变量的功能。ES5使用的是函数作用域，只有函数可以创造作用域，也就是说，只存在全局作用域和函数作用域。

ES6之前变量声明只有`var`这一条途径，为了兼容之前的代码，哪怕在ES6中，只要你用了`var`，那么就相当于你是在声明这个作用域是函数作用域而非块级作用域。显然，这可能会导致一些问题，因为`if`，`for`这些块级语句你不可能不用，那么当你用了一些你以为的临时变量，实际就可能会污染整个作用域。

```js
function sample1() {
    if (true) {
      var bar = "bar";
    }
    if (true) {
      let foo = "foo";
    }
    console.log(bar); // bar
    console.log(foo); // Error
  }
```

上面的例子，bar所在的块级作用域会失效。

## 变量提升
变量提升有三种 -- 你可以回顾一下你之前所学的语言中是否存在下面几种变量提升。

下面所提及的变量的位置，可以为作用域内的任意位置。
1. 提前开辟内存空间（创建） -- 当代码执行到作用域开头处，为变量开辟内存空间。
2. 提前初始化变量 -- 当代码执行到作用域开头处，变量被初始化，指定一个值（如undefined）。
3. 提前赋值 -- 当代码执行到作用域开头处，执行变量的声明赋值语句。

使用`var`声明存在第1和2种的变量提升，也就是代码执行前，会把本作用域的由var声明的变量初始化过程全提升到头部，即无‘暂时性死区’（不管执行到哪一步，你一定能访问它），这显然是有坏处的。（ES6中也是一样的）

而ES6新引入的`let`和`const`则是第一种变量提升，也是在编程语言中最为常见的。

而对于`function`变量，在js中属于第三种变量提升，我个人认为还是蛮好的，不会像c/c++需要你在调用函数前必须确保前面有函数声明。



